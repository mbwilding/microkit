use proc_macro::TokenStream;
use quote::quote;
use std::fs;
use std::path::PathBuf;
use syn::{Data, DeriveInput, Fields, Item, ItemFn, LitStr, parse_macro_input};

/// Discovers and registers all endpoint modules in a directory
#[proc_macro]
pub fn discover_endpoints(input: TokenStream) -> TokenStream {
    let path_lit = parse_macro_input!(input as LitStr);
    let endpoints_path = path_lit.value();

    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");

    let full_path = PathBuf::from(manifest_dir).join(&endpoints_path);

    struct EndpointInfo {
        module_name: String,
        handlers: Vec<String>,
    }

    let mut endpoints = Vec::new();

    if full_path.exists() && full_path.is_dir() {
        match fs::read_dir(&full_path) {
            Ok(entries) => {
                for entry in entries.flatten() {
                    let path = entry.path();

                    if path.is_file()
                        && let Some(file_name) = path.file_name()
                        && let Some(file_name_str) = file_name.to_str()
                        && file_name_str.ends_with(".rs")
                        && file_name_str != "mod.rs"
                    {
                        let module_name = &file_name_str[..file_name_str.len() - 3];
                        if let Ok(content) = fs::read_to_string(&path)
                            && let Ok(syntax_tree) = syn::parse_file(&content)
                        {
                            let mut handlers = Vec::new();

                            for item in syntax_tree.items {
                                if let Item::Fn(func) = item
                                    && has_utoipa_path_attr(&func)
                                {
                                    handlers.push(func.sig.ident.to_string());
                                }
                            }

                            if !handlers.is_empty() {
                                endpoints.push(EndpointInfo {
                                    module_name: module_name.to_string(),
                                    handlers,
                                });
                            }
                        }
                    }
                }
            }
            Err(e) => {
                return syn::Error::new(
                    path_lit.span(),
                    format!("Failed to read directory '{}': {}", full_path.display(), e),
                )
                .to_compile_error()
                .into();
            }
        }
    } else {
        return syn::Error::new(
            path_lit.span(),
            format!("Directory '{}' does not exist", full_path.display()),
        )
        .to_compile_error()
        .into();
    }

    endpoints.sort_by(|a, b| a.module_name.cmp(&b.module_name));

    if endpoints.is_empty() {
        return syn::Error::new(
            path_lit.span(),
            format!("No endpoint modules found in '{}'", full_path.display()),
        )
        .to_compile_error()
        .into();
    }

    let module_idents: Vec<_> = endpoints
        .iter()
        .map(|ep| syn::Ident::new(&ep.module_name, proc_macro2::Span::call_site()))
        .collect();

    let module_decls = module_idents.iter().map(|ident| {
        quote! {
            pub mod #ident;
        }
    });

    let register_calls = endpoints.iter().map(|ep| {
        let module_ident = syn::Ident::new(&ep.module_name, proc_macro2::Span::call_site());
        let handler_idents: Vec<_> = ep
            .handlers
            .iter()
            .map(|h| syn::Ident::new(h, proc_macro2::Span::call_site()))
            .collect();

        quote! {
            if let Some(db) = &service.database {
                let router = ::utoipa_axum::router::OpenApiRouter::new()
                    .routes(::utoipa_axum::routes!(#(#module_ident::#handler_idents),*))
                    .with_state(db.clone());
                service.add_route(router);
            }
        }
    });

    let expanded = quote! {
        #(#module_decls)*

        /// Automatically registers all discovered endpoint modules
        ///
        /// This function is generated by the `discover_endpoints!` macro and will
        /// register all handler functions found in each endpoint module
        pub fn init_endpoints(
            service: &mut microkit::MicroKit
        ) -> anyhow::Result<()> {
            #(#register_calls)*
            Ok(())
        }
    };

    TokenStream::from(expanded)
}

/// Check if a function has a #[utoipa::path] attribute
fn has_utoipa_path_attr(func: &ItemFn) -> bool {
    for attr in &func.attrs {
        if attr.path().segments.len() == 2 {
            let segments: Vec<_> = attr.path().segments.iter().collect();
            if segments[0].ident == "utoipa" && segments[1].ident == "path" {
                return true;
            }
        }
    }
    false
}

/// Registers endpoint modules with a MicroKit service
#[proc_macro]
pub fn register_endpoints(input: TokenStream) -> TokenStream {
    use syn::{
        Ident, Token,
        parse::{Parse, ParseStream},
        punctuated::Punctuated,
    };

    struct RegisterEndpointsInput {
        service: Ident,
        db: Ident,
        module: Ident,
        endpoints: Vec<Ident>,
    }

    impl Parse for RegisterEndpointsInput {
        fn parse(input: ParseStream) -> syn::Result<Self> {
            let service: Ident = input.parse()?;
            input.parse::<Token![,]>()?;
            let db: Ident = input.parse()?;
            input.parse::<Token![,]>()?;
            let module: Ident = input.parse()?;
            input.parse::<Token![=>]>()?;

            let content;
            syn::bracketed!(content in input);
            let endpoints_punct = Punctuated::<Ident, Token![,]>::parse_terminated(&content)?;
            let endpoints = endpoints_punct.into_iter().collect();

            Ok(RegisterEndpointsInput {
                service,
                db,
                module,
                endpoints,
            })
        }
    }

    let RegisterEndpointsInput {
        service,
        db,
        module,
        endpoints,
    } = parse_macro_input!(input as RegisterEndpointsInput);

    let register_calls = endpoints.iter().map(|name| {
        quote! {
            #service.add_route(#module::#name::api(&#db)?);
        }
    });

    let expanded = quote! {
        #(#register_calls)*
    };

    TokenStream::from(expanded)
}

/// Derive macro for entities with creation tracking
#[proc_macro_derive(CreationTracked)]
pub fn derive_creation_tracked(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;

    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => {
                return syn::Error::new_spanned(
                    &input,
                    "CreationTracked can only be derived for structs with named fields",
                )
                .to_compile_error()
                .into();
            }
        },
        _ => {
            return syn::Error::new_spanned(
                &input,
                "CreationTracked can only be derived for structs",
            )
            .to_compile_error()
            .into();
        }
    };

    let mut has_creation_system = false;
    let mut has_creation_key = false;
    let mut has_generated_on = false;

    for field in fields {
        if let Some(ident) = &field.ident {
            if ident == "creation_system" {
                has_creation_system = true;
            }
            if ident == "creation_key" {
                has_creation_key = true;
            }
            if ident == "generated_on" {
                has_generated_on = true;
            }
        }
    }

    if !has_creation_system {
        return syn::Error::new_spanned(
            &input,
            "CreationTracked requires a `creation_system: String` field",
        )
        .to_compile_error()
        .into();
    }

    if !has_creation_key {
        return syn::Error::new_spanned(
            &input,
            "CreationTracked requires a `creation_key: String` field",
        )
        .to_compile_error()
        .into();
    }

    if !has_generated_on {
        return syn::Error::new_spanned(
            &input,
            "CreationTracked requires a `generated_on: chrono::DateTime<chrono::Utc>` field",
        )
        .to_compile_error()
        .into();
    }

    // Generate the implementation
    let expanded = quote! {
        impl microkit::entity::CreationTracking for #name {
            fn creation_system(&self) -> &str {
                &self.creation_system
            }

            fn creation_key(&self) -> &str {
                &self.creation_key
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for event contracts that automatically adds creation tracking fields and generated_on
#[proc_macro_attribute]
pub fn event_contract(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let mut input = parse_macro_input!(item as DeriveInput);
    let name = &input.ident;
    let vis = &input.vis;

    let fields = match &mut input.data {
        Data::Struct(data) => match &mut data.fields {
            Fields::Named(fields) => fields,
            _ => {
                return syn::Error::new_spanned(
                    &input,
                    "event_contract can only be used with structs with named fields",
                )
                .to_compile_error()
                .into();
            }
        },
        _ => {
            return syn::Error::new_spanned(&input, "event_contract can only be used with structs")
                .to_compile_error()
                .into();
        }
    };

    for field in fields.named.iter() {
        if let Some(ident) = &field.ident
            && (ident == "creation_system" || ident == "creation_key" || ident == "generated_on")
        {
            return syn::Error::new_spanned(
                    field,
                    format!("#[event_contract] automatically adds '{}' field - please remove it from your struct", ident)
                )
                .to_compile_error()
                .into();
        }
    }

    let field_names: Vec<_> = fields
        .named
        .iter()
        .filter_map(|f| f.ident.as_ref())
        .cloned()
        .collect();

    let field_types: Vec<_> = fields.named.iter().map(|f| f.ty.clone()).collect();

    let creation_system_field: syn::Field = syn::parse_quote! {
        #vis creation_system: String
    };

    let creation_key_field: syn::Field = syn::parse_quote! {
        #vis creation_key: String
    };

    let generated_on_field: syn::Field = syn::parse_quote! {
        #vis generated_on: chrono::DateTime<chrono::Utc>
    };

    fields.named.insert(0, generated_on_field);
    fields.named.insert(0, creation_key_field);
    fields.named.insert(0, creation_system_field);

    let attrs = &input.attrs;
    let generics = &input.generics;
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let all_fields = &fields.named;

    let expanded = quote! {
        #(#attrs)*
        #vis struct #name #generics {
            #all_fields
        }

        impl #impl_generics #name #ty_generics #where_clause {
            #vis fn new(
                creation_system: String,
                creation_key: String,
                #(#field_names: #field_types),*
            ) -> Self {
                Self {
                    creation_system,
                    creation_key,
                    generated_on: chrono::Utc::now(),
                    #(#field_names),*
                }
            }
        }

        impl #impl_generics microkit::entity::CreationTracking for #name #ty_generics #where_clause {
            fn creation_system(&self) -> &str {
                &self.creation_system
            }

            fn creation_key(&self) -> &str {
                &self.creation_key
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for api contracts that automatically adds creation tracking fields
#[proc_macro_attribute]
pub fn api_contract(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let mut input = parse_macro_input!(item as DeriveInput);
    let name = &input.ident;
    let vis = &input.vis;

    let fields = match &mut input.data {
        Data::Struct(data) => match &mut data.fields {
            Fields::Named(fields) => fields,
            _ => {
                return syn::Error::new_spanned(
                    &input,
                    "api_contract can only be used with structs with named fields",
                )
                .to_compile_error()
                .into();
            }
        },
        _ => {
            return syn::Error::new_spanned(&input, "api_contract can only be used with structs")
                .to_compile_error()
                .into();
        }
    };

    for field in fields.named.iter() {
        if let Some(ident) = &field.ident
            && (ident == "creation_system" || ident == "creation_key")
        {
            return syn::Error::new_spanned(
                    field,
                    format!("#[api_contract] automatically adds '{}' field - please remove it from your struct", ident)
                )
                .to_compile_error()
                .into();
        }
    }

    let field_names: Vec<_> = fields
        .named
        .iter()
        .filter_map(|f| f.ident.as_ref())
        .cloned()
        .collect();

    let field_types: Vec<_> = fields.named.iter().map(|f| f.ty.clone()).collect();

    let creation_system_field: syn::Field = syn::parse_quote! {
        #vis creation_system: String
    };

    let creation_key_field: syn::Field = syn::parse_quote! {
        #vis creation_key: String
    };

    fields.named.insert(0, creation_key_field);
    fields.named.insert(0, creation_system_field);

    let attrs = &input.attrs;
    let generics = &input.generics;
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let all_fields = &fields.named;

    let expanded = quote! {
        #(#attrs)*
        #vis struct #name #generics {
            #all_fields
        }

        impl #impl_generics #name #ty_generics #where_clause {
            #vis fn new(
                creation_system: String,
                creation_key: String,
                #(#field_names: #field_types),*
            ) -> Self {
                Self {
                    creation_system,
                    creation_key,
                    #(#field_names),*
                }
            }
        }

        impl #impl_generics microkit::entity::CreationTracking for #name #ty_generics #where_clause {
            fn creation_system(&self) -> &str {
                &self.creation_system
            }

            fn creation_key(&self) -> &str {
                &self.creation_key
            }
        }
    };

    TokenStream::from(expanded)
}
